<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rotation Bisectors</title>
<link rel="stylesheet" href="../assets/style.css">
<style>
  :root {
    --accent:#2dd4bf; --pole:#60a5fa; --first:#f59e0b; --last:#f43f5e;
    --muted:#9fb0c2; --ink:#e6edf3; --grid:#1c2633; --subgrid:#131a23; --warn:#ef4444;
  }
  html, body { height:100%; margin:0; background:#0b0f14; color:var(--ink); }
  body { font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif; }
  .wrap { position:relative; height:100vh; width:100vw; overflow:hidden; }
  .stage { position:absolute; inset:0; }
  svg { display:block; width:100%; height:100%; }
  .title {
    position:absolute; top:1rem; left:1rem; padding:.35rem .65rem;
    border:1px solid #1d2634; border-radius:.6rem; background:#0f162280;
    font-size:13px; color:var(--muted); letter-spacing:.02em;
  }
  .hint {
    position:absolute; left:1rem; bottom:1rem;
    background:#0f1622cc; border:1px solid #1d2634; border-radius:.6rem;
    padding:.55rem .75rem; font-size:13px; color:var(--muted); max-width:320px; line-height:1.4;
  }
  .legend {
    position:absolute; right:1rem; bottom:1rem;
    background:#0f162280; border:1px solid #1d2634; border-radius:.6rem;
    padding:.55rem .8rem; font-size:12px; color:var(--muted); display:flex; flex-direction:column; gap:.35rem;
  }
  .legend .swatch {
    display:inline-block; width:14px; height:6px; margin-right:.5rem; border-radius:999px;
  }
  .legend .swatch-ref { background:var(--accent); }
  .legend .swatch-eff { background:var(--warn); }
  .controls {
    position:absolute; top:1rem; right:1rem;
    width:230px; background:#0f1622f0; border:1px solid #1d2634; border-radius:.75rem;
    padding:.75rem .9rem; display:flex; flex-direction:column; gap:.55rem;
    box-shadow:0 10px 25px #0006;
  }
  .controls h2 {
    margin:0; font-size:14px; font-weight:600; color:var(--ink);
  }
  .section-label { margin-top:.4rem; font-size:12px; text-transform:uppercase; letter-spacing:.08em; color:#6b7a91; }
  .divider { height:1px; background:#1d2634; margin:.35rem 0; }
  .toggle {
    display:flex; align-items:center; gap:.55rem;
    cursor:pointer; user-select:none;
  }
  .toggle input {
    appearance:none; width:36px; height:20px; border-radius:999px;
    border:1px solid #1d2634; background:#131b28; position:relative;
    transition:background .2s ease;
  }
  .toggle input::after {
    content:''; position:absolute; top:2px; left:2px; width:16px; height:16px;
    border-radius:50%; background:#4b5a70; transition:transform .2s ease, background .2s ease;
  }
  .toggle input:checked { background:#2563eb55; border-color:#2563ebaa; }
  .toggle input:checked::after { transform:translateX(16px); background:#2dd4bf; }
  .origin-selected line { stroke-width:3.1px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="title">Rotation — Connected Structures</div>
  <div class="stage">
    <svg id="scene-rot" viewBox="0 0 1200 700" aria-label="rotation playground">
      <defs>
        <pattern id="subgrid-rot" width="25" height="25" patternUnits="userSpaceOnUse">
          <path d="M25 0H0V25" fill="none" stroke="var(--subgrid)" stroke-width="1"/>
        </pattern>
        <pattern id="grid-rot" width="100" height="100" patternUnits="userSpaceOnUse">
          <rect width="100" height="100" fill="url(#subgrid-rot)"/>
          <path d="M100 0H0V100" fill="none" stroke="var(--grid)" stroke-width="1.2"/>
        </pattern>
        <marker id="arrow-rot" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
          <path d="M0,0 L10,5 L0,10 z" fill="var(--accent)"/>
        </marker>
      </defs>
      <rect x="0" y="0" width="1200" height="700" fill="url(#grid-rot)"/>
      <g>
        <line x1="600" y1="0"   x2="600" y2="700" stroke="#263140" stroke-width="1.4"/>
        <line x1="0"   y1="350" x2="1200" y2="350" stroke="#263140" stroke-width="1.4"/>
        <text x="610" y="20" fill="#3f4a5d" font-size="12">Y</text>
        <text x="1185" y="365" fill="#3f4a5d" font-size="12" text-anchor="end">X</text>
      </g>
      <g id="rot-connections"></g>
      <g id="rot-global"></g>
      <g id="rot-bisectors"></g>
      <g id="rot-reference"></g>
      <g id="rot-poles"></g>
      <g id="rot-labels"></g>
      <g id="rot-angles"></g>
      <g id="rot-handles"></g>
    </svg>
    <div class="hint" id="rot-hint">
      Drag each red-centred origin to move a structure. Use the turquoise rotation handle to spin it.
      The green reference line connects the poles; the red effective line is the conductor bisector between neighbours.
      Manage rotation preservation and alignment from the panel on the right.
    </div>
    <div class="legend">
      <div><span class="swatch swatch-ref"></span>Reference orientation</div>
      <div><span class="swatch swatch-eff"></span>Effective orientation</div>
    </div>
    <div class="controls" id="rot-controls">
      <h2>Orientation Controls</h2>
      <label class="toggle">
        <input type="checkbox" id="toggle-align">
        <span>Align all to S1↔S3</span>
      </label>
      <div class="divider"></div>
      <span class="section-label">Structures</span>
      <label class="toggle">
        <input type="checkbox" data-structure="0" id="toggle-auto-0">
        <span>S1 Rotation is invariant</span>
      </label>
      <label class="toggle">
        <input type="checkbox" data-structure="1" id="toggle-auto-1">
        <span>S2 Rotation is invariant</span>
      </label>
      <label class="toggle">
        <input type="checkbox" data-structure="2" id="toggle-auto-2">
        <span>S3 Rotation is invariant</span>
      </label>
      <p class="note">When rotation is invariant the structure keeps its angle despite neighbour moves.</p>
    </div>
  </div>
</div>

<script>
(() => {
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const WIDTH = 1200;
  const HEIGHT = 700;
  const MARGIN = 40;
  const POLE_HALF = 80;
  const EFFECT_EXTRA = 36;

  const scene = document.getElementById('scene-rot');
  const gConnections = document.getElementById('rot-connections');
  const gGlobal = document.getElementById('rot-global');
  const gBisectors = document.getElementById('rot-bisectors');
  const gReference = document.getElementById('rot-reference');
  const gPoles = document.getElementById('rot-poles');
  const gLabels = document.getElementById('rot-labels');
  const gAngles = document.getElementById('rot-angles');
  const gHandles = document.getElementById('rot-handles');

  const alignToggle = document.getElementById('toggle-align');
  const autoToggles = Array.from(document.querySelectorAll('[data-structure]'));

  function clientToSvg(x, y){
    const pt = scene.createSVGPoint();
    pt.x = x; pt.y = y;
    const p = pt.matrixTransform(scene.getScreenCTM().inverse());
    return { x: p.x, y: p.y };
  }

  function clampPoint(pt){
    return {
      x: clamp(pt.x, MARGIN, WIDTH - MARGIN),
      y: clamp(pt.y, MARGIN, HEIGHT - MARGIN)
    };
  }

  function svgToScreen(x, y){
    const pt = scene.createSVGPoint();
    pt.x = x; pt.y = y;
    const screen = pt.matrixTransform(scene.getScreenCTM());
    return { x: screen.x, y: screen.y };
  }

  function wrapAngle(theta){
    const twoPi = Math.PI * 2;
    return ((theta + Math.PI) % twoPi + twoPi) % twoPi - Math.PI;
  }

  const RAD2DEG = 180 / Math.PI;

  let structures = [
    { origin:{ x: 460, y: 360 }, angle: -0.44, rotationInvariant:false, rotationOffset:null },
    { origin:{ x: 660, y: 360 }, angle: -0.25, rotationInvariant:false, rotationOffset:null },
    { origin:{ x: 860, y: 360 }, angle:  0.32, rotationInvariant:false, rotationOffset:null }
  ];
  let dragState = null;
  let globalAlign = false;
  let alignState = { enabled:false, axisParam:0, axisOffset:0 };

  function alignmentActive(){
    return globalAlign && alignState.enabled && structures.length >= 3;
  }

  function disableAlignment(){
    globalAlign = false;
    alignState.enabled = false;
    if (alignToggle){
      alignToggle.checked = false;
    }
  }

  function getAlignmentAxis(){
    if (structures.length < 3) return null;
    const origin = structures[0].origin;
    const target = structures[structures.length - 1].origin;
    const dx = target.x - origin.x;
    const dy = target.y - origin.y;
    const len = Math.hypot(dx, dy);
    if (len < 1e-3) return null;
    const dir = { x: dx / len, y: dy / len };
    const perp = { x: -dir.y, y: dir.x };
    return { origin, dir, perp };
  }

  function computeAlignmentState(){
    const axis = getAlignmentAxis();
    if (!axis) return null;
    const mid = structures[1].origin;
    const rel = { x: mid.x - axis.origin.x, y: mid.y - axis.origin.y };
    const axisParam = rel.x * axis.dir.x + rel.y * axis.dir.y;
    const axisOffset = rel.x * axis.perp.x + rel.y * axis.perp.y;
    return { axisParam, axisOffset };
  }

  function clampParamAlongAxis(axis, offset, param){
    const compute = (p) => ({
      x: axis.origin.x + axis.dir.x * p + axis.perp.x * offset,
      y: axis.origin.y + axis.dir.y * p + axis.perp.y * offset
    });
    let current = param;
    for (let i = 0; i < 5; i++){
      let pos = compute(current);
      let adjusted = false;
      if (pos.x < MARGIN && Math.abs(axis.dir.x) > 1e-6){
        current = ((MARGIN - axis.origin.x) - axis.perp.x * offset) / axis.dir.x;
        adjusted = true;
      } else if (pos.x > WIDTH - MARGIN && Math.abs(axis.dir.x) > 1e-6){
        current = (((WIDTH - MARGIN) - axis.origin.x) - axis.perp.x * offset) / axis.dir.x;
        adjusted = true;
      }
      pos = compute(current);
      if (pos.y < MARGIN && Math.abs(axis.dir.y) > 1e-6){
        current = ((MARGIN - axis.origin.y) - axis.perp.y * offset) / axis.dir.y;
        adjusted = true;
      } else if (pos.y > HEIGHT - MARGIN && Math.abs(axis.dir.y) > 1e-6){
        current = (((HEIGHT - MARGIN) - axis.origin.y) - axis.perp.y * offset) / axis.dir.y;
        adjusted = true;
      }
      if (!adjusted) break;
    }
    return { param: current, position: compute(current) };
  }

  function applyAlignmentPosition(axis){
    if (!alignmentActive() || !axis) return;
    const clamped = clampParamAlongAxis(axis, alignState.axisOffset, alignState.axisParam);
    alignState.axisParam = clamped.param;
    const s2 = structures[1];
    s2.origin.x = clamped.position.x;
    s2.origin.y = clamped.position.y;
  }

  function syncControls(){
    if (alignToggle) alignToggle.checked = globalAlign && alignState.enabled;
    autoToggles.forEach(toggle => {
      const idx = Number(toggle.dataset.structure);
      if (structures[idx]) toggle.checked = !!structures[idx].rotationInvariant;
    });
  }

  if (alignToggle){
    alignToggle.addEventListener('change', () => {
      if (alignToggle.checked){
        const state = computeAlignmentState();
        const axis = getAlignmentAxis();
        if (!state || !axis){
          disableAlignment();
          draw();
          return;
        }
        globalAlign = true;
        alignState = { enabled:true, axisParam: state.axisParam, axisOffset: state.axisOffset };
        applyAlignmentPosition(axis);
      } else {
        disableAlignment();
      }
      draw();
    });
  }

  autoToggles.forEach(toggle => {
    const idx = Number(toggle.dataset.structure);
    toggle.addEventListener('change', () => {
      if (!structures[idx]) return;
      structures[idx].rotationInvariant = toggle.checked;
      structures[idx].rotationOffset = null;
      draw();
    });
  });

  function makeCircle(cx, cy, r, fill, stroke = 'none', strokeWidth = 1.5){
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', cx); c.setAttribute('cy', cy);
    c.setAttribute('r', r);
    c.setAttribute('fill', fill);
    c.setAttribute('stroke', stroke);
    c.setAttribute('stroke-width', strokeWidth);
    return c;
  }

  function makeLine(x1, y1, x2, y2, stroke, width, dash = ''){
    const ln = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    ln.setAttribute('x1', x1);
    ln.setAttribute('y1', y1);
    ln.setAttribute('x2', x2);
    ln.setAttribute('y2', y2);
    ln.setAttribute('stroke', stroke);
    ln.setAttribute('stroke-width', width);
    if (dash) ln.setAttribute('stroke-dasharray', dash);
    ln.setAttribute('stroke-linecap', 'round');
    return ln;
  }

  function makeCrossLines(x, y, size, color, width){
    const half = size / 2;
    const lines = [
      makeLine(x - half, y - half, x + half, y + half, color, width),
      makeLine(x - half, y + half, x + half, y - half, color, width)
    ];
    lines.forEach(line => line.setAttribute('stroke-linecap', 'round'));
    return lines;
  }

  function polePositions(structure){
    const dx = Math.cos(structure.angle) * POLE_HALF;
    const dy = Math.sin(structure.angle) * POLE_HALF;
    return [
      { x: structure.origin.x - dx, y: structure.origin.y - dy },
      { x: structure.origin.x + dx, y: structure.origin.y + dy }
    ];
  }

  function angleBetween(dirA, dirB){
    const dot = Math.abs(dirA.x * dirB.x + dirA.y * dirB.y);
    const clamped = Math.min(1, Math.max(-1, dot));
    return Math.acos(clamped) * RAD2DEG;
  }

  function startDrag(type, structure, pointerId, extra = {}){
    const { index = structures.indexOf(structure), offset } = extra;
    dragState = { type, structure, pointerId, index, offset, moved:false };
    try {
      scene.setPointerCapture(pointerId);
    } catch (err) {
      // ignore environments that disallow capture
    }
  }

  function finishDrag(pointerId){
    if (!dragState || dragState.pointerId !== pointerId) return;
    try {
      scene.releasePointerCapture(pointerId);
    } catch (err) {
      // ignore release issues when pointer already freed
    }
    dragState = null;
  }

  function computeBisectorVector(idx, orientationData){
    if (idx <= 0 || idx >= orientationData.length - 1) return null;
    const prev = orientationData[idx - 1].structure;
    const midStruct = orientationData[idx].structure;
    const next = orientationData[idx + 1].structure;

    const v1 = { x: prev.origin.x - midStruct.origin.x, y: prev.origin.y - midStruct.origin.y };
    const v2 = { x: next.origin.x - midStruct.origin.x, y: next.origin.y - midStruct.origin.y };

    const len1 = Math.hypot(v1.x, v1.y);
    const len2 = Math.hypot(v2.x, v2.y);
    if (len1 < 1e-3 || len2 < 1e-3) return null;

    v1.x /= len1; v1.y /= len1;
    v2.x /= len2; v2.y /= len2;

    let bis = { x: v1.x + v2.x, y: v1.y + v2.y };
    let bisLen = Math.hypot(bis.x, bis.y);
    if (bisLen < 1e-3){
      bis = { x: -v1.y, y: v1.x }; // fallback to perpendicular when vectors oppose each other
      bisLen = Math.hypot(bis.x, bis.y);
    }
    bis.x /= bisLen;
    bis.y /= bisLen;
    return bis;
  }

  function computeEffectiveDirection(idx, orientationData){
    if (orientationData.length === 0) return null;
    if (idx > 0 && idx < orientationData.length - 1){
      return computeBisectorVector(idx, orientationData);
    }
    if (orientationData.length < 2) return null;
    const neighborIdx = idx === 0 ? 1 : orientationData.length - 2;
    if (neighborIdx === idx || !orientationData[neighborIdx]) return null;
    const self = orientationData[idx].structure;
    const neighbor = orientationData[neighborIdx].structure;
    const vx = neighbor.origin.x - self.origin.x;
    const vy = neighbor.origin.y - self.origin.y;
    const len = Math.hypot(vx, vy);
    if (len < 1e-3) return null;
    return { x: -vy / len, y: vx / len };
  }

  function drawEffectiveLine(idx, orientationData, dirVec){
    const eff = dirVec || computeEffectiveDirection(idx, orientationData);
    if (!eff) return null;
    const midStruct = orientationData[idx].structure;
    const span = POLE_HALF + EFFECT_EXTRA;
    const line = makeLine(
      midStruct.origin.x - eff.x * span,
      midStruct.origin.y - eff.y * span,
      midStruct.origin.x + eff.x * span,
      midStruct.origin.y + eff.y * span,
      'var(--warn)', 2.7
    );
    line.classList.add('effective');
    line.setAttribute('pointer-events', 'none');
    gBisectors.appendChild(line);

    const dir = orientationData[idx].dir;
    const angleDeg = angleBetween(eff, dir);
    return { origin: midStruct.origin, angleDeg };
  }

  function attachOriginDrag(handle, structure, index){
    handle.addEventListener('pointerdown', (e) => {
      const p = clientToSvg(e.clientX, e.clientY);
      const offset = {
        dx: structure.origin.x - p.x,
        dy: structure.origin.y - p.y
      };
      startDrag('origin', structure, e.pointerId, { offset, index });
      draw();
      e.preventDefault();
    });
  }

  function attachRotationDrag(handle, structure, index){
    handle.addEventListener('pointerdown', (e) => {
      startDrag('rotation', structure, e.pointerId, { index });
      draw();
      e.preventDefault();
    });
  }

  function drawOriginGlyph(structure, index){
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const crossLines = makeCrossLines(structure.origin.x, structure.origin.y, 14, 'var(--warn)', 2.4);
    crossLines.forEach(line => group.appendChild(line));
    group.style.cursor = dragState && dragState.structure === structure && dragState.type === 'origin' ? 'grabbing' : 'grab';
    attachOriginDrag(group, structure, index);
    return group;
  }

  function draw(){
    gConnections.innerHTML = '';
    gGlobal.innerHTML = '';
    gBisectors.innerHTML = '';
    gReference.innerHTML = '';
    gPoles.innerHTML = '';
    gLabels.innerHTML = '';
    gAngles.innerHTML = '';
    gHandles.innerHTML = '';

    let axisForAlignment = null;
    if (alignmentActive()){
      axisForAlignment = getAlignmentAxis();
      if (!axisForAlignment){
        disableAlignment();
      } else {
        applyAlignmentPosition(axisForAlignment);
        const updated = computeAlignmentState();
        if (updated){
          alignState.axisParam = updated.axisParam;
          alignState.axisOffset = updated.axisOffset;
        }
      }
    }

    const orientationData = structures.map((structure, index) => ({
      index,
      structure,
      dir: { x: Math.cos(structure.angle), y: Math.sin(structure.angle) },
      poles: polePositions(structure)
    }));

    let globalDir = null;
    if (globalAlign && alignState.enabled && axisForAlignment){
      globalDir = { x: axisForAlignment.perp.x, y: axisForAlignment.perp.y };
      const first = structures[0].origin;
      const last = structures[structures.length - 1].origin;
      const globalLine = makeLine(first.x, first.y, last.x, last.y, '#a855f7', 2.4);
      globalLine.setAttribute('pointer-events', 'none');
      gGlobal.appendChild(globalLine);
    }

    const effectiveDirs = orientationData.map((_, idx) => {
      if (globalDir) return { x: globalDir.x, y: globalDir.y };
      return computeEffectiveDirection(idx, orientationData);
    });

    orientationData.forEach((data, idx) => {
      const eff = effectiveDirs[idx];
      if (!eff) return;
      const effAngle = Math.atan2(eff.y, eff.x);
      let currentAngle = data.structure.angle;
      const isRotationDrag = !!(dragState && dragState.structure === data.structure && dragState.type === 'rotation');

      if (data.structure.rotationInvariant){
        if (isRotationDrag){
          data.structure.rotationOffset = wrapAngle(currentAngle - effAngle);
        } else if (data.structure.rotationOffset == null){
          data.structure.rotationOffset = wrapAngle(currentAngle - effAngle);
        }
        const offset = data.structure.rotationOffset ?? 0;
        const desiredAngle = effAngle + offset;
        const delta = wrapAngle(desiredAngle - currentAngle);
        if (Math.abs(delta) > 1e-3){
          data.structure.angle = desiredAngle;
          currentAngle = desiredAngle;
        }
        // keep stored offset aligned with the true separation between reference and effective angles
        const refreshedOffset = wrapAngle(currentAngle - effAngle);
        if (Math.abs(wrapAngle(refreshedOffset - (data.structure.rotationOffset ?? 0))) > 1e-4){
          data.structure.rotationOffset = refreshedOffset;
        }
      } else {
        data.structure.rotationOffset = null;
        // rotation freely follows manual edits; no automatic alignment applied
      }
    });

    orientationData.forEach((data) => {
      const angle = data.structure.angle;
      data.dir = { x: Math.cos(angle), y: Math.sin(angle) };
      data.poles = polePositions(data.structure);
    });

    orientationData.forEach((data, idx) => {
      if (idx < orientationData.length - 1){
        const next = orientationData[idx + 1].structure.origin;
        const ln = makeLine(data.structure.origin.x, data.structure.origin.y, next.x, next.y, '#253345', 1.6);
        ln.setAttribute('pointer-events', 'none');
        gConnections.appendChild(ln);
      }
    });

    orientationData.forEach((data) => {
      const [poleA, poleB] = data.poles;
      const refLine = makeLine(poleA.x, poleA.y, poleB.x, poleB.y, 'var(--accent)', 3);
      refLine.setAttribute('pointer-events', 'none');
      gReference.appendChild(refLine);

      const poleRadius = 7.2;
      const poleAEl = makeCircle(poleA.x, poleA.y, poleRadius, '#142030', 'var(--accent)', 2);
      const poleBEl = makeCircle(poleB.x, poleB.y, poleRadius, '#142030', 'var(--accent)', 2);
      poleAEl.style.cursor = dragState && dragState.structure === data.structure && dragState.type === 'rotation' ? 'grabbing' : 'grab';
      poleBEl.style.cursor = dragState && dragState.structure === data.structure && dragState.type === 'rotation' ? 'grabbing' : 'grab';
      attachRotationDrag(poleAEl, data.structure, data.index);
      attachRotationDrag(poleBEl, data.structure, data.index);
      gPoles.appendChild(poleAEl);
      gPoles.appendChild(poleBEl);

      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', data.structure.origin.x + 14);
      label.setAttribute('y', data.structure.origin.y - 16);
      label.setAttribute('fill', '#9fb0c2');
      label.setAttribute('font-size', '12');
      label.setAttribute('pointer-events', 'none');
      label.textContent = `S${data.index + 1}`;
      gLabels.appendChild(label);

      const originGlyph = drawOriginGlyph(data.structure, data.index);
      gHandles.appendChild(originGlyph);
    });

    orientationData.forEach((data, idx) => {
      const info = drawEffectiveLine(idx, orientationData, effectiveDirs[idx]);
      if (info){
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', info.origin.x + 14);
        text.setAttribute('y', info.origin.y + 16);
        text.setAttribute('fill', 'var(--warn)');
        text.setAttribute('font-size', '12');
        text.setAttribute('pointer-events', 'none');
        text.textContent = `Δ ${info.angleDeg.toFixed(1)}°`;
        gAngles.appendChild(text);
      }
    });

    if (alignToggle) alignToggle.checked = globalAlign && alignState.enabled;
    autoToggles.forEach(toggle => {
      const idx = Number(toggle.dataset.structure);
      if (structures[idx]) toggle.checked = !!structures[idx].rotationInvariant;
    });
  }

  scene.addEventListener('pointermove', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    const p = clientToSvg(e.clientX, e.clientY);
    if (dragState.type === 'origin'){
      const offset = dragState.offset || { dx:0, dy:0 };
      const index = dragState.index ?? structures.indexOf(dragState.structure);
      const aligned = alignmentActive();
      const axis = aligned ? getAlignmentAxis() : null;
      if (aligned && !axis){
        disableAlignment();
      }

      if (aligned && axis && index === 1){
        const targetPoint = { x: p.x + offset.dx, y: p.y + offset.dy };
        const rel = { x: targetPoint.x - axis.origin.x, y: targetPoint.y - axis.origin.y };
        let newParam = rel.x * axis.dir.x + rel.y * axis.dir.y;
        const clamped = clampParamAlongAxis(axis, alignState.axisOffset, newParam);
        alignState.axisParam = clamped.param;
        dragState.structure.origin.x = clamped.position.x;
        dragState.structure.origin.y = clamped.position.y;
        dragState.moved = true;
        draw();
        return;
      }

      const next = {
        x: p.x + offset.dx,
        y: p.y + offset.dy
      };
      const clamped = clampPoint(next);
      if (Math.abs(clamped.x - dragState.structure.origin.x) > 0.5 || Math.abs(clamped.y - dragState.structure.origin.y) > 0.5){
        dragState.moved = true;
        dragState.structure.origin.x = clamped.x;
        dragState.structure.origin.y = clamped.y;
      if (aligned && axis && (index === 0 || index === structures.length - 1)){
          const newAxis = getAlignmentAxis();
          if (newAxis){
            applyAlignmentPosition(newAxis);
            const updated = computeAlignmentState();
            if (updated){
              alignState.axisParam = updated.axisParam;
              alignState.axisOffset = updated.axisOffset;
            }
          }
        }
      }
    } else if (dragState.type === 'rotation'){
      const vector = {
        x: p.x - dragState.structure.origin.x,
        y: p.y - dragState.structure.origin.y
      };
      if (Math.hypot(vector.x, vector.y) > 1e-3){
        dragState.moved = true;
        dragState.structure.angle = Math.atan2(vector.y, vector.x);
      }
    }
    draw();
  });

  scene.addEventListener('pointerup', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    const state = { ...dragState };
    finishDrag(e.pointerId);
    draw();
  });
  scene.addEventListener('pointercancel', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    finishDrag(e.pointerId);
    draw();
  });

  draw();
})();
</script>
</body>
</html>
