<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rotation Bisectors</title>
<link rel="stylesheet" href="../assets/style.css">
<style>
  :root {
    --accent:#2dd4bf; --pole:#60a5fa; --first:#f59e0b; --last:#f43f5e;
    --muted:#9fb0c2; --ink:#e6edf3; --grid:#1c2633; --subgrid:#131a23; --warn:#ef4444;
  }
  html, body { height:100%; margin:0; background:#0b0f14; color:var(--ink); }
  body { font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif; }
  .wrap { position:relative; height:100vh; width:100vw; overflow:hidden; }
  .stage { position:absolute; inset:0; }
  svg { display:block; width:100%; height:100%; }
  .title {
    position:absolute; top:1rem; left:1rem; padding:.35rem .65rem;
    border:1px solid #1d2634; border-radius:.6rem; background:#0f162280;
    font-size:13px; color:var(--muted); letter-spacing:.02em;
  }
  .hint {
    position:absolute; left:1rem; bottom:1rem;
    background:#0f1622cc; border:1px solid #1d2634; border-radius:.6rem;
    padding:.55rem .75rem; font-size:13px; color:var(--muted); max-width:320px; line-height:1.4;
  }
  .legend {
    position:absolute; right:1rem; bottom:1rem;
    background:#0f162280; border:1px solid #1d2634; border-radius:.6rem;
    padding:.55rem .8rem; font-size:12px; color:var(--muted); display:flex; flex-direction:column; gap:.35rem;
  }
  .legend .swatch {
    display:inline-block; width:14px; height:6px; margin-right:.5rem; border-radius:999px;
  }
  .legend .swatch-ref { background:var(--accent); }
  .legend .swatch-eff { background:var(--warn); }
  .prop-panel {
    position:absolute; background:#0f1622f0; border:1px solid #1d2634; border-radius:.65rem;
    padding:.65rem .8rem; width:220px; color:var(--muted); font-size:13px;
    display:flex; flex-direction:column; gap:.55rem; pointer-events:auto;
    box-shadow:0 10px 25px #0006;
  }
  .prop-panel[hidden] { display:none; }
  .prop-panel h2 {
    margin:0; font-size:13px; font-weight:600; color:var(--ink); display:flex; justify-content:space-between; align-items:center;
  }
  .prop-close {
    background:none; border:none; color:var(--muted); cursor:pointer; font-size:13px; padding:0;
  }
  .prop-close:hover { color:var(--ink); }
  .toggle {
    display:flex; align-items:center; gap:.55rem;
    cursor:pointer; user-select:none;
  }
  .toggle input {
    appearance:none; width:36px; height:20px; border-radius:999px;
    border:1px solid #1d2634; background:#131b28; position:relative;
    transition:background .2s ease;
  }
  .toggle input::after {
    content:''; position:absolute; top:2px; left:2px; width:16px; height:16px;
    border-radius:50%; background:#4b5a70; transition:transform .2s ease, background .2s ease;
  }
  .toggle input:checked { background:#2563eb55; border-color:#2563ebaa; }
  .toggle input:checked::after { transform:translateX(16px); background:#2dd4bf; }
  .origin-selected line { stroke-width:3.1px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="title">Rotation — Connected Structures</div>
  <div class="stage">
    <svg id="scene-rot" viewBox="0 0 1200 700" aria-label="rotation playground">
      <defs>
        <pattern id="subgrid-rot" width="25" height="25" patternUnits="userSpaceOnUse">
          <path d="M25 0H0V25" fill="none" stroke="var(--subgrid)" stroke-width="1"/>
        </pattern>
        <pattern id="grid-rot" width="100" height="100" patternUnits="userSpaceOnUse">
          <rect width="100" height="100" fill="url(#subgrid-rot)"/>
          <path d="M100 0H0V100" fill="none" stroke="var(--grid)" stroke-width="1.2"/>
        </pattern>
        <marker id="arrow-rot" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
          <path d="M0,0 L10,5 L0,10 z" fill="var(--accent)"/>
        </marker>
      </defs>
      <rect x="0" y="0" width="1200" height="700" fill="url(#grid-rot)"/>
      <g>
        <line x1="600" y1="0"   x2="600" y2="700" stroke="#263140" stroke-width="1.4"/>
        <line x1="0"   y1="350" x2="1200" y2="350" stroke="#263140" stroke-width="1.4"/>
        <text x="610" y="20" fill="#3f4a5d" font-size="12">Y</text>
        <text x="1185" y="365" fill="#3f4a5d" font-size="12" text-anchor="end">X</text>
      </g>
      <g id="rot-connections"></g>
      <g id="rot-global"></g>
      <g id="rot-bisectors"></g>
      <g id="rot-reference"></g>
      <g id="rot-poles"></g>
      <g id="rot-labels"></g>
      <g id="rot-angles"></g>
      <g id="rot-handles"></g>
    </svg>
    <div class="hint" id="rot-hint">
      Drag each red-centred origin to move a structure. Use the turquoise rotation handle to spin it.
      The green reference line connects the poles; the red effective line is the conductor bisector between neighbours.
      Δ shows the offset angle between them.
    </div>
    <div class="legend">
      <div><span class="swatch swatch-ref"></span>Reference orientation</div>
      <div><span class="swatch swatch-eff"></span>Effective orientation</div>
    </div>
    <div class="prop-panel" id="rot-panel" hidden>
      <h2 id="rot-panel-title">Structure <button class="prop-close" id="rot-panel-close">×</button></h2>
      <label class="toggle">
        <input type="checkbox" id="rot-panel-auto" checked>
        <span>Auto reorient</span>
      </label>
      <p class="note">When enabled, the structure turns with the effective orientation.</p>
      <label class="toggle">
        <input type="checkbox" id="rot-align-toggle">
        <span>Align all to S1↔S3</span>
      </label>
      <p class="note">Force every effective orientation to stay perpendicular to the line between S1 and S3.</p>
    </div>
  </div>
</div>

<script>
(() => {
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const WIDTH = 1200;
  const HEIGHT = 700;
  const MARGIN = 40;
  const MAX_STRUCTS = 3;
  const POLE_HALF = 80;
  const EFFECT_EXTRA = 36;

  const scene = document.getElementById('scene-rot');
  const gConnections = document.getElementById('rot-connections');
  const gGlobal = document.getElementById('rot-global');
  const gBisectors = document.getElementById('rot-bisectors');
  const gReference = document.getElementById('rot-reference');
  const gPoles = document.getElementById('rot-poles');
  const gLabels = document.getElementById('rot-labels');
  const gAngles = document.getElementById('rot-angles');
  const gHandles = document.getElementById('rot-handles');

  const propPanel = document.getElementById('rot-panel');
  const propTitle = document.getElementById('rot-panel-title');
  const propAuto = document.getElementById('rot-panel-auto');
  const alignToggle = document.getElementById('rot-align-toggle');
  const propClose = document.getElementById('rot-panel-close');

  function clientToSvg(x, y){
    const pt = scene.createSVGPoint();
    pt.x = x; pt.y = y;
    const p = pt.matrixTransform(scene.getScreenCTM().inverse());
    return { x: p.x, y: p.y };
  }

  function clampPoint(pt){
    return {
      x: clamp(pt.x, MARGIN, WIDTH - MARGIN),
      y: clamp(pt.y, MARGIN, HEIGHT - MARGIN)
    };
  }

  function svgToScreen(x, y){
    const pt = scene.createSVGPoint();
    pt.x = x; pt.y = y;
    const screen = pt.matrixTransform(scene.getScreenCTM());
    return { x: screen.x, y: screen.y };
  }

  const RAD2DEG = 180 / Math.PI;

  let structures = [
    { origin:{ x: 460, y: 360 }, angle: -0.44, autoReorient:true },
    { origin:{ x: 660, y: 360 }, angle: -0.25, autoReorient:true },
    { origin:{ x: 860, y: 360 }, angle:  0.32, autoReorient:true }
  ];
  let dragState = null;
  let selectedIndex = null;
  let globalAlign = false;

  function updatePanel(){
    if (selectedIndex === null || !structures[selectedIndex]){
      propPanel.hidden = true;
      return;
    }
    const label = `Structure S${selectedIndex + 1}`;
    propTitle.textContent = label;
    propAuto.checked = !!structures[selectedIndex].autoReorient;
    alignToggle.checked = globalAlign;
    propPanel.hidden = false;

    const origin = structures[selectedIndex].origin;
    const stageRect = scene.getBoundingClientRect();
    const screenPos = svgToScreen(origin.x, origin.y);

    propPanel.style.visibility = 'hidden';
    const panelRect = propPanel.getBoundingClientRect();
    propPanel.style.visibility = '';

    let left = screenPos.x - stageRect.left - panelRect.width / 2;
    let top = screenPos.y - stageRect.top - panelRect.height - 18;

    const minLeft = 8;
    const maxLeft = stageRect.width - panelRect.width - 8;
    left = clamp(left, minLeft, maxLeft);

    const minTop = 8;
    top = Math.max(minTop, top);

    propPanel.style.left = `${left}px`;
    propPanel.style.top = `${top}px`;
  }

  function selectStructure(idx){
    if (idx === selectedIndex) return;
    selectedIndex = idx;
    updatePanel();
    draw();
  }

  propAuto.addEventListener('change', () => {
    if (selectedIndex === null || !structures[selectedIndex]) return;
    structures[selectedIndex].autoReorient = propAuto.checked;
    draw();
  });

  alignToggle.addEventListener('change', () => {
    globalAlign = alignToggle.checked;
    draw();
  });

  document.addEventListener('pointerdown', (e) => {
    if (propPanel.hidden) return;
    const path = e.composedPath ? e.composedPath() : [];
    if (path.includes(propPanel)) return;
    selectStructure(null);
  });

  function makeCircle(cx, cy, r, fill, stroke = 'none', strokeWidth = 1.5){
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', cx); c.setAttribute('cy', cy);
    c.setAttribute('r', r);
    c.setAttribute('fill', fill);
    c.setAttribute('stroke', stroke);
    c.setAttribute('stroke-width', strokeWidth);
    return c;
  }

  function makeLine(x1, y1, x2, y2, stroke, width, dash = ''){
    const ln = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    ln.setAttribute('x1', x1);
    ln.setAttribute('y1', y1);
    ln.setAttribute('x2', x2);
    ln.setAttribute('y2', y2);
    ln.setAttribute('stroke', stroke);
    ln.setAttribute('stroke-width', width);
    if (dash) ln.setAttribute('stroke-dasharray', dash);
    ln.setAttribute('stroke-linecap', 'round');
    return ln;
  }

  function makeCrossLines(x, y, size, color, width){
    const half = size / 2;
    const lines = [
      makeLine(x - half, y - half, x + half, y + half, color, width),
      makeLine(x - half, y + half, x + half, y - half, color, width)
    ];
    lines.forEach(line => line.setAttribute('stroke-linecap', 'round'));
    return lines;
  }

  function polePositions(structure){
    const dx = Math.cos(structure.angle) * POLE_HALF;
    const dy = Math.sin(structure.angle) * POLE_HALF;
    return [
      { x: structure.origin.x - dx, y: structure.origin.y - dy },
      { x: structure.origin.x + dx, y: structure.origin.y + dy }
    ];
  }

  function angleBetween(dirA, dirB){
    const dot = Math.abs(dirA.x * dirB.x + dirA.y * dirB.y);
    const clamped = Math.min(1, Math.max(-1, dot));
    return Math.acos(clamped) * RAD2DEG;
  }

  function startDrag(type, structure, pointerId, extra = {}){
    const { index = structures.indexOf(structure), offset } = extra;
    dragState = { type, structure, pointerId, index, offset, moved:false };
    try {
      scene.setPointerCapture(pointerId);
    } catch (err) {
      // ignore environments that disallow capture
    }
  }

  function finishDrag(pointerId){
    if (!dragState || dragState.pointerId !== pointerId) return;
    try {
      scene.releasePointerCapture(pointerId);
    } catch (err) {
      // ignore release issues when pointer already freed
    }
    dragState = null;
  }

  function computeBisectorVector(idx, orientationData){
    if (idx <= 0 || idx >= orientationData.length - 1) return null;
    const prev = orientationData[idx - 1].structure;
    const midStruct = orientationData[idx].structure;
    const next = orientationData[idx + 1].structure;

    const v1 = { x: prev.origin.x - midStruct.origin.x, y: prev.origin.y - midStruct.origin.y };
    const v2 = { x: next.origin.x - midStruct.origin.x, y: next.origin.y - midStruct.origin.y };

    const len1 = Math.hypot(v1.x, v1.y);
    const len2 = Math.hypot(v2.x, v2.y);
    if (len1 < 1e-3 || len2 < 1e-3) return null;

    v1.x /= len1; v1.y /= len1;
    v2.x /= len2; v2.y /= len2;

    let bis = { x: v1.x + v2.x, y: v1.y + v2.y };
    let bisLen = Math.hypot(bis.x, bis.y);
    if (bisLen < 1e-3){
      bis = { x: -v1.y, y: v1.x }; // fallback to perpendicular when vectors oppose each other
      bisLen = Math.hypot(bis.x, bis.y);
    }
    bis.x /= bisLen;
    bis.y /= bisLen;
    return bis;
  }

  function computeEffectiveDirection(idx, orientationData){
    if (orientationData.length === 0) return null;
    if (idx > 0 && idx < orientationData.length - 1){
      return computeBisectorVector(idx, orientationData);
    }
    if (orientationData.length < 2) return null;
    const neighborIdx = idx === 0 ? 1 : orientationData.length - 2;
    if (neighborIdx === idx || !orientationData[neighborIdx]) return null;
    const self = orientationData[idx].structure;
    const neighbor = orientationData[neighborIdx].structure;
    const vx = neighbor.origin.x - self.origin.x;
    const vy = neighbor.origin.y - self.origin.y;
    const len = Math.hypot(vx, vy);
    if (len < 1e-3) return null;
    return { x: -vy / len, y: vx / len };
  }

  function drawEffectiveLine(idx, orientationData, dirVec){
    const eff = dirVec || computeEffectiveDirection(idx, orientationData);
    if (!eff) return null;
    const midStruct = orientationData[idx].structure;
    const span = POLE_HALF + EFFECT_EXTRA;
    const line = makeLine(
      midStruct.origin.x - eff.x * span,
      midStruct.origin.y - eff.y * span,
      midStruct.origin.x + eff.x * span,
      midStruct.origin.y + eff.y * span,
      'var(--warn)', 2.7
    );
    line.classList.add('effective');
    line.setAttribute('pointer-events', 'none');
    gBisectors.appendChild(line);

    const dir = orientationData[idx].dir;
    const angleDeg = angleBetween(eff, dir);
    return { origin: midStruct.origin, angleDeg };
  }

  function attachOriginDrag(handle, structure, index){
    handle.addEventListener('pointerdown', (e) => {
      const p = clientToSvg(e.clientX, e.clientY);
      const offset = {
        dx: structure.origin.x - p.x,
        dy: structure.origin.y - p.y
      };
      startDrag('origin', structure, e.pointerId, { offset, index });
      draw();
      e.preventDefault();
    });
  }

  function attachRotationDrag(handle, structure, index){
    handle.addEventListener('pointerdown', (e) => {
      startDrag('rotation', structure, e.pointerId, { index });
      draw();
      e.preventDefault();
    });
  }

  function drawOriginGlyph(structure, index){
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const crossLines = makeCrossLines(structure.origin.x, structure.origin.y, 14, 'var(--warn)', 2.4);
    crossLines.forEach(line => group.appendChild(line));
    group.style.cursor = dragState && dragState.structure === structure && dragState.type === 'origin' ? 'grabbing' : 'grab';
    if (index === selectedIndex) group.classList.add('origin-selected');
    attachOriginDrag(group, structure, index);
    return group;
  }

  function draw(){
    gConnections.innerHTML = '';
    gGlobal.innerHTML = '';
    gBisectors.innerHTML = '';
    gReference.innerHTML = '';
    gPoles.innerHTML = '';
    gLabels.innerHTML = '';
    gAngles.innerHTML = '';
    gHandles.innerHTML = '';

    const orientationData = structures.map((structure, index) => ({
      index,
      structure,
      dir: { x: Math.cos(structure.angle), y: Math.sin(structure.angle) },
      poles: polePositions(structure)
    }));

    let globalDir = null;
    if (globalAlign && structures.length >= 2){
      const first = structures[0];
      const last = structures[structures.length - 1];
      const axis = { x: last.origin.x - first.origin.x, y: last.origin.y - first.origin.y };
      const axisLen = Math.hypot(axis.x, axis.y);
      if (axisLen > 1e-3){
        const axisNorm = { x: axis.x / axisLen, y: axis.y / axisLen };
        globalDir = { x: -axisNorm.y, y: axisNorm.x };
        const globalLine = makeLine(first.origin.x, first.origin.y, last.origin.x, last.origin.y, '#a855f7', 2.4);
        globalLine.setAttribute('pointer-events', 'none');
        gGlobal.appendChild(globalLine);
      }
    }

    const effectiveDirs = orientationData.map((_, idx) => {
      if (globalDir) return { x: globalDir.x, y: globalDir.y };
      return computeEffectiveDirection(idx, orientationData);
    });
    orientationData.forEach((data, idx) => {
      const eff = effectiveDirs[idx];
      if (!eff) return;
      if (!data.structure.autoReorient) return;
      if (dragState && dragState.structure === data.structure && dragState.type === 'rotation') return;
      const targetAngle = Math.atan2(eff.y, eff.x);
      if (Math.abs(targetAngle - data.structure.angle) > 1e-3){
        data.structure.angle = targetAngle;
      }
    });

    orientationData.forEach((data) => {
      const angle = data.structure.angle;
      data.dir = { x: Math.cos(angle), y: Math.sin(angle) };
      data.poles = polePositions(data.structure);
    });

    orientationData.forEach((data, idx) => {
      if (idx < orientationData.length - 1){
        const next = orientationData[idx + 1].structure.origin;
        const ln = makeLine(data.structure.origin.x, data.structure.origin.y, next.x, next.y, '#253345', 1.6);
        ln.setAttribute('pointer-events', 'none');
        gConnections.appendChild(ln);
      }
    });

    orientationData.forEach((data) => {
      const [poleA, poleB] = data.poles;
      const refLine = makeLine(poleA.x, poleA.y, poleB.x, poleB.y, 'var(--accent)', 3);
      refLine.setAttribute('pointer-events', 'none');
      gReference.appendChild(refLine);

      const poleRadius = 7.2;
      const poleAEl = makeCircle(poleA.x, poleA.y, poleRadius, '#142030', 'var(--accent)', 2);
      const poleBEl = makeCircle(poleB.x, poleB.y, poleRadius, '#142030', 'var(--accent)', 2);
      poleAEl.style.cursor = dragState && dragState.structure === data.structure && dragState.type === 'rotation' ? 'grabbing' : 'grab';
      poleBEl.style.cursor = dragState && dragState.structure === data.structure && dragState.type === 'rotation' ? 'grabbing' : 'grab';
      attachRotationDrag(poleAEl, data.structure, data.index);
      attachRotationDrag(poleBEl, data.structure, data.index);
      gPoles.appendChild(poleAEl);
      gPoles.appendChild(poleBEl);

      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', data.structure.origin.x + 14);
      label.setAttribute('y', data.structure.origin.y - 16);
      label.setAttribute('fill', '#9fb0c2');
      label.setAttribute('font-size', '12');
      label.setAttribute('pointer-events', 'none');
      label.textContent = `S${data.index + 1}`;
      gLabels.appendChild(label);

      const originGlyph = drawOriginGlyph(data.structure, data.index);
      gHandles.appendChild(originGlyph);
    });

    orientationData.forEach((data, idx) => {
      const info = drawEffectiveLine(idx, orientationData, effectiveDirs[idx]);
      if (info){
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', info.origin.x + 14);
        text.setAttribute('y', info.origin.y + 16);
        text.setAttribute('fill', 'var(--warn)');
        text.setAttribute('font-size', '12');
        text.setAttribute('pointer-events', 'none');
        text.textContent = `Δ ${info.angleDeg.toFixed(1)}°`;
        gAngles.appendChild(text);
      }
    });

    updatePanel();
  }

  scene.addEventListener('pointermove', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    const p = clientToSvg(e.clientX, e.clientY);
    if (dragState.type === 'origin'){
      const offset = dragState.offset || { dx:0, dy:0 };
      const next = {
        x: p.x + offset.dx,
        y: p.y + offset.dy
      };
      const clamped = clampPoint(next);
      if (Math.abs(clamped.x - dragState.structure.origin.x) > 0.5 || Math.abs(clamped.y - dragState.structure.origin.y) > 0.5){
        dragState.moved = true;
        dragState.structure.origin.x = clamped.x;
        dragState.structure.origin.y = clamped.y;
      }
    } else if (dragState.type === 'rotation'){
      const vector = {
        x: p.x - dragState.structure.origin.x,
        y: p.y - dragState.structure.origin.y
      };
      if (Math.hypot(vector.x, vector.y) > 1e-3){
        if (!dragState.autoDisabled && dragState.structure.autoReorient){
          dragState.structure.autoReorient = false;
          dragState.autoDisabled = true;
          if (dragState.index === selectedIndex) updatePanel();
        }
        dragState.moved = true;
        dragState.structure.angle = Math.atan2(vector.y, vector.x);
      }
    }
    draw();
  });

  scene.addEventListener('pointerup', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    const state = { ...dragState };
    finishDrag(e.pointerId);
    if (state.type === 'origin' && !state.moved){
      selectStructure(state.index);
    } else {
      draw();
    }
  });
  scene.addEventListener('pointercancel', (e) => {
    if (!dragState || e.pointerId !== dragState.pointerId) return;
    finishDrag(e.pointerId);
    draw();
  });

  draw();
})();
</script>
</body>
</html>
  function svgToScreen(x, y){
    const pt = scene.createSVGPoint();
    pt.x = x; pt.y = y;
    const { x: sx, y: sy } = pt.matrixTransform(scene.getScreenCTM());
    return { x: sx, y: sy };
  }
